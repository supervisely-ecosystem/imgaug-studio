
<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="Docutils 0.17: http://docutils.sourceforge.net/" name="generator"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>my_script module — Python  documentation</title>
<link href="_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="_static/copybutton.css" rel="stylesheet" type="text/css"/>
<!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
<script data-url_root="./" id="documentation_options" src="_static/documentation_options.js" type="text/javascript"></script>
<script src="_static/jquery.js"></script>
<script src="_static/underscore.js"></script>
<script src="_static/doctools.js"></script>
<script src="_static/clipboard.min.js"></script>
<script src="_static/copybutton.js"></script>
<script src="_static/js/theme.js" type="text/javascript"></script>
<link href="genindex.html" rel="index" title="Index"/>
<link href="search.html" rel="search" title="Search"/>
<link href="modules.html" rel="prev" title="my_file"/>
<style>
       ul.simple li {
         list-style: disc;
         margin-left: 24px;
       }
     </style></head>
<body class=""><div><div><dd>
<p><strong>Deprecated.</strong> Augmenter to apply affine transformations to images using
cv2 (i.e. opencv) backend.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This augmenter is deprecated since 0.4.0.
Use <code class="docutils literal notranslate"><span class="pre">Affine(...,</span> <span class="pre">backend='cv2')</span></code> instead.</p>
</div>
<p>Affine transformations
involve:</p>
<blockquote>
<div><ul class="simple">
<li><p>Translation (“move” image on the x-/y-axis)</p></li>
<li><p>Rotation</p></li>
<li><p>Scaling (“zoom” in/out)</p></li>
<li><p>Shear (move one side of the image, turning a square into a trapezoid)</p></li>
</ul>
</div></blockquote>
<p>All such transformations can create “new” pixels in the image without a
defined content, e.g. if the image is translated to the left, pixels
are created on the right.
A method has to be defined to deal with these pixel values. The
parameters <cite>cval</cite> and <cite>mode</cite> of this class deal with this.</p>
<p>Some transformations involve interpolations between several pixels
of the input image to generate output pixel values. The parameter <cite>order</cite>
deals with the method of interpolation used for this.</p>
<p>Deprecated since 0.4.0.</p>
<p><strong>Supported dtypes</strong>:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">uint8</span></code>: yes; fully tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint16</span></code>: ?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint32</span></code>: ?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint64</span></code>: ?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int8</span></code>: ?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int16</span></code>: ?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int32</span></code>: ?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int64</span></code>: ?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float16</span></code>: ?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float32</span></code>: ?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float64</span></code>: ?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float128</span></code>: ?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code>: ?</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> (<em>number</em><em> or </em><em>tuple of number</em><em> or </em><em>list of number</em><em> or </em><em>imgaug.parameters.StochasticParameter</em><em> or </em><em>dict {"x": number/tuple/list/StochasticParameter</em><em>, </em><em>"y": number/tuple/list/StochasticParameter}</em><em>, </em><em>optional</em>) – <p>Scaling factor to use, where <code class="docutils literal notranslate"><span class="pre">1.0</span></code> denotes “no change” and
<code class="docutils literal notranslate"><span class="pre">0.5</span></code> is zoomed out to <code class="docutils literal notranslate"><span class="pre">50</span></code> percent of the original size.</p>
<blockquote>
<div><ul>
<li><p>If a single number, then that value will be used for all images.</p></li>
<li><p>If a tuple <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>, then a value will be uniformly sampled
per image from the interval <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b]</span></code>. That value will be
used identically for both x- and y-axis.</p></li>
<li><p>If a list, then a random value will be sampled from that list
per image (again, used for both x- and y-axis).</p></li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, then from that parameter a value
will be sampled per image (again, used for both x- and y-axis).</p></li>
<li><p>If a dictionary, then it is expected to have the keys <code class="docutils literal notranslate"><span class="pre">x</span></code>
and/or <code class="docutils literal notranslate"><span class="pre">y</span></code>. Each of these keys can have the same values as
described above. Using a dictionary allows to set different
values for the two axis and sampling will then happen
<em>independently</em> per axis, resulting in samples that differ
between the axes.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>translate_percent</strong> (<em>number</em><em> or </em><em>tuple of number</em><em> or </em><em>list of number</em><em> or </em><em>imgaug.parameters.StochasticParameter</em><em> or </em><em>dict {"x": number/tuple/list/StochasticParameter</em><em>, </em><em>"y": number/tuple/list/StochasticParameter}</em><em>, </em><em>optional</em>) – <p>Translation as a fraction of the image height/width (x-translation,
y-translation), where <code class="docutils literal notranslate"><span class="pre">0</span></code> denotes “no change” and <code class="docutils literal notranslate"><span class="pre">0.5</span></code> denotes
“half of the axis size”.</p>
<blockquote>
<div><ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code> then equivalent to <code class="docutils literal notranslate"><span class="pre">0.0</span></code> unless <cite>translate_px</cite> has
a value other than <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p>If a single number, then that value will be used for all images.</p></li>
<li><p>If a tuple <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>, then a value will be uniformly sampled
per image from the interval <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b]</span></code>. That sampled fraction
value will be used identically for both x- and y-axis.</p></li>
<li><p>If a list, then a random value will be sampled from that list
per image (again, used for both x- and y-axis).</p></li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, then from that parameter a value
will be sampled per image (again, used for both x- and y-axis).</p></li>
<li><p>If a dictionary, then it is expected to have the keys <code class="docutils literal notranslate"><span class="pre">x</span></code>
and/or <code class="docutils literal notranslate"><span class="pre">y</span></code>. Each of these keys can have the same values as
described above. Using a dictionary allows to set different
values for the two axis and sampling will then happen
<em>independently</em> per axis, resulting in samples that differ
between the axes.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>translate_px</strong> (<em>int</em><em> or </em><em>tuple of int</em><em> or </em><em>list of int</em><em> or </em><em>imgaug.parameters.StochasticParameter</em><em> or </em><em>dict {"x": int/tuple/list/StochasticParameter</em><em>, </em><em>"y": int/tuple/list/StochasticParameter}</em><em>, </em><em>optional</em>) – <p>Translation in pixels.</p>
<blockquote>
<div><ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code> then equivalent to <code class="docutils literal notranslate"><span class="pre">0</span></code> unless <cite>translate_percent</cite>
has a value other than <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p>If a single int, then that value will be used for all images.</p></li>
<li><p>If a tuple <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>, then a value will be uniformly sampled
per image from the discrete interval <code class="docutils literal notranslate"><span class="pre">[a..b]</span></code>. That number
will be used identically for both x- and y-axis.</p></li>
<li><p>If a list, then a random value will be sampled from that list
per image (again, used for both x- and y-axis).</p></li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, then from that parameter a value
will be sampled per image (again, used for both x- and y-axis).</p></li>
<li><p>If a dictionary, then it is expected to have the keys <code class="docutils literal notranslate"><span class="pre">x</span></code>
and/or <code class="docutils literal notranslate"><span class="pre">y</span></code>. Each of these keys can have the same values as
described above. Using a dictionary allows to set different
values for the two axis and sampling will then happen
<em>independently</em> per axis, resulting in samples that differ
between the axes.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>rotate</strong> (<em>number</em><em> or </em><em>tuple of number</em><em> or </em><em>list of number</em><em> or </em><em>imgaug.parameters.StochasticParameter</em><em>, </em><em>optional</em>) – <p>Rotation in degrees (<strong>NOT</strong> radians), i.e. expected value range is
around <code class="docutils literal notranslate"><span class="pre">[-360,</span> <span class="pre">360]</span></code>. Rotation happens around the <em>center</em> of the
image, not the top left corner as in some other frameworks.</p>
<blockquote>
<div><ul>
<li><p>If a number, then that value will be used for all images.</p></li>
<li><p>If a tuple <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>, then a value will be uniformly sampled
per image from the interval <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b]</span></code> and used as the rotation
value.</p></li>
<li><p>If a list, then a random value will be sampled from that list
per image.</p></li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, then this parameter will be used to
sample the rotation value per image.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>shear</strong> (<em>number</em><em> or </em><em>tuple of number</em><em> or </em><em>list of number</em><em> or </em><em>imgaug.parameters.StochasticParameter</em><em>, </em><em>optional</em>) – <p>Shear in degrees (<strong>NOT</strong> radians), i.e. expected value range is
around <code class="docutils literal notranslate"><span class="pre">[-360,</span> <span class="pre">360]</span></code>.</p>
<blockquote>
<div><ul>
<li><p>If a number, then that value will be used for all images.</p></li>
<li><p>If a tuple <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>, then a value will be uniformly sampled
per image from the interval <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b]</span></code> and be used as the
rotation value.</p></li>
<li><p>If a list, then a random value will be sampled from that list
per image.</p></li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, then this parameter will be used
to sample the shear value per image.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>order</strong> (<em>int</em><em> or </em><em>list of int</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>imaug.ALL</em><em> or </em><em>imgaug.parameters.StochasticParameter</em><em>, </em><em>optional</em>) – <p>Interpolation order to use. Allowed are:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">cv2.INTER_NEAREST</span></code> (nearest-neighbor interpolation)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cv2.INTER_LINEAR</span></code> (bilinear interpolation, used by default)</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cv2.INTER_CUBIC</span></code> (bicubic interpolation over <code class="docutils literal notranslate"><span class="pre">4x4</span></code> pixel</dt><dd><p>neighborhood)</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">cv2.INTER_LANCZOS4</span></code></p></li>
<li><p>string <code class="docutils literal notranslate"><span class="pre">nearest</span></code> (same as <code class="docutils literal notranslate"><span class="pre">cv2.INTER_NEAREST</span></code>)</p></li>
<li><p>string <code class="docutils literal notranslate"><span class="pre">linear</span></code> (same as <code class="docutils literal notranslate"><span class="pre">cv2.INTER_LINEAR</span></code>)</p></li>
<li><p>string <code class="docutils literal notranslate"><span class="pre">cubic</span></code> (same as <code class="docutils literal notranslate"><span class="pre">cv2.INTER_CUBIC</span></code>)</p></li>
<li><p>string <code class="docutils literal notranslate"><span class="pre">lanczos4</span></code> (same as <code class="docutils literal notranslate"><span class="pre">cv2.INTER_LANCZOS</span></code>)</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">INTER_NEAREST</span></code> (nearest neighbour interpolation) and
<code class="docutils literal notranslate"><span class="pre">INTER_NEAREST</span></code> (linear interpolation) are the fastest.</p>
<blockquote>
<div><ul>
<li><p>If a single <code class="docutils literal notranslate"><span class="pre">int</span></code>, then that order will be used for all images.</p></li>
<li><p>If a string, then it must be one of: <code class="docutils literal notranslate"><span class="pre">nearest</span></code>, <code class="docutils literal notranslate"><span class="pre">linear</span></code>,
<code class="docutils literal notranslate"><span class="pre">cubic</span></code>, <code class="docutils literal notranslate"><span class="pre">lanczos4</span></code>.</p></li>
<li><p>If an iterable of <code class="docutils literal notranslate"><span class="pre">int</span></code>/<code class="docutils literal notranslate"><span class="pre">str</span></code>, then for each image a random
value will be sampled from that iterable (i.e. list of allowed
order values).</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">imgaug.ALL</span></code>, then equivalant to list <code class="docutils literal notranslate"><span class="pre">[cv2.INTER_NEAREST,</span>
<span class="pre">cv2.INTER_LINEAR,</span> <span class="pre">cv2.INTER_CUBIC,</span> <span class="pre">cv2.INTER_LANCZOS4]</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, then that parameter is queried per
image to sample the order value to use.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>cval</strong> (<em>number</em><em> or </em><em>tuple of number</em><em> or </em><em>list of number</em><em> or </em><em>imaug.ALL</em><em> or </em><em>imgaug.parameters.StochasticParameter</em><em>, </em><em>optional</em>) – <p>The constant value to use when filling in newly created pixels.
(E.g. translating by 1px to the right will create a new 1px-wide
column of pixels on the left of the image).  The value is only used
when <cite>mode=constant</cite>. The expected value range is <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">255]</span></code> for
<code class="docutils literal notranslate"><span class="pre">uint8</span></code> images. It may be a float value.</p>
<blockquote>
<div><ul>
<li><p>If this is a single number, then that value will be used
(e.g. 0 results in black pixels).</p></li>
<li><p>If a tuple <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>, then three values (for three image
channels) will be uniformly sampled per image from the
interval <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b]</span></code>.</p></li>
<li><p>If a list, then a random value will be sampled from that list
per image.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">imgaug.ALL</span></code> then equivalent to tuple <a href="#id1"><span class="problematic" id="id2">``</span></a>(0, 255)`.</p></li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, a new value will be sampled from
the parameter per image.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>mode</strong> (<em>int</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>list of int</em><em> or </em><em>imgaug.ALL</em><em> or </em><em>imgaug.parameters.StochasticParameter</em><em>,</em>) – <p>optional
Method to use when filling in newly created pixels.
Same meaning as in OpenCV’s border mode. Let <code class="docutils literal notranslate"><span class="pre">abcdefgh</span></code> be an image’s
content and <code class="docutils literal notranslate"><span class="pre">|</span></code> be an image boundary after which new pixels are
filled in, then the valid modes and their behaviour are the following:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REPLICATE</span></code>: <code class="docutils literal notranslate"><span class="pre">aaaaaa|abcdefgh|hhhhhhh</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT</span></code>: <code class="docutils literal notranslate"><span class="pre">fedcba|abcdefgh|hgfedcb</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT_101</span></code>: <code class="docutils literal notranslate"><span class="pre">gfedcb|abcdefgh|gfedcba</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_WRAP</span></code>: <code class="docutils literal notranslate"><span class="pre">cdefgh|abcdefgh|abcdefg</span></code></p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code>: <code class="docutils literal notranslate"><span class="pre">iiiiii|abcdefgh|iiiiiii</span></code>,</dt><dd><p>where <code class="docutils literal notranslate"><span class="pre">i</span></code> is the defined cval.</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">replicate</span></code>: Same as <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REPLICATE</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reflect</span></code>: Same as <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reflect_101</span></code>: Same as <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT_101</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wrap</span></code>: Same as <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_WRAP</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constant</span></code>: Same as <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code>.</p></li>
</ul>
</div></blockquote>
<p>The datatype of the parameter may be:</p>
<blockquote>
<div><ul>
<li><p>If a single <code class="docutils literal notranslate"><span class="pre">int</span></code>, then it must be one of the <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_*</span></code>
constants.</p></li>
<li><p>If a single string, then it must be one of: <code class="docutils literal notranslate"><span class="pre">replicate</span></code>,
<code class="docutils literal notranslate"><span class="pre">reflect</span></code>, <code class="docutils literal notranslate"><span class="pre">reflect_101</span></code>, <code class="docutils literal notranslate"><span class="pre">wrap</span></code>, <code class="docutils literal notranslate"><span class="pre">constant</span></code>.</p></li>
<li><p>If a list of <code class="docutils literal notranslate"><span class="pre">int</span></code>/<code class="docutils literal notranslate"><span class="pre">str</span></code>, then per image a random mode will
be picked from that list.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">imgaug.ALL</span></code>, then a random mode from all possible modes
will be picked.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, then the mode will be sampled from
that parameter per image, i.e. it must return only the above
mentioned strings.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>seed</strong> (<em>None</em><em> or </em><em>int</em><em> or </em><em>imgaug.random.RNG</em><em> or </em><em>numpy.random.Generator</em><em> or </em><em>numpy.random.BitGenerator</em><em> or </em><em>numpy.random.SeedSequence</em><em> or </em><em>numpy.random.RandomState</em><em>, </em><em>optional</em>) – See <code class="xref py py-func docutils literal notranslate"><span class="pre">__init__()</span></code>.</p></li>
<li><p><strong>name</strong> (<em>None</em><em> or </em><em>str</em><em>, </em><em>optional</em>) – See <code class="xref py py-func docutils literal notranslate"><span class="pre">__init__()</span></code>.</p></li>
<li><p><strong>random_state</strong> (<em>None</em><em> or </em><em>int</em><em> or </em><em>imgaug.random.RNG</em><em> or </em><em>numpy.random.Generator</em><em> or </em><em>numpy.random.BitGenerator</em><em> or </em><em>numpy.random.SeedSequence</em><em> or </em><em>numpy.random.RandomState</em><em>, </em><em>optional</em>) – Old name for parameter <cite>seed</cite>.
Its usage will not yet cause a deprecation warning,
but it is still recommended to use <cite>seed</cite> now.
Outdated since 0.4.0.</p></li>
<li><p><strong>deterministic</strong> (<em>bool</em><em>, </em><em>optional</em>) – Deprecated since 0.4.0.
See method <code class="docutils literal notranslate"><span class="pre">to_deterministic()</span></code> for an alternative and for
details about what the “deterministic mode” actually does.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">imgaug.augmenters</span> <span class="k">as</span> <span class="nn">iaa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Zoom in on all images by a factor of <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
<p>Translate all images on the x- and y-axis by 16 pixels (towards the
bottom right) and fill up any new pixels with zero (black values).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">translate_percent</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>Translate all images on the x- and y-axis by <code class="docutils literal notranslate"><span class="pre">10</span></code> percent of their
width/height (towards the bottom right). The pixel values are computed
per axis based on that axis’ size. Fill up any new pixels with zero
(black values).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">rotate</span><span class="o">=</span><span class="mi">35</span><span class="p">)</span>
</pre></div>
</div>
<p>Rotate all images by <code class="docutils literal notranslate"><span class="pre">35</span></code> <em>degrees</em>. Fill up any new pixels with zero
(black values).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">shear</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
<p>Shear all images by <code class="docutils literal notranslate"><span class="pre">15</span></code> <em>degrees</em>. Fill up any new pixels with zero
(black values).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
</pre></div>
</div>
<p>Translate all images on the x- and y-axis by a random value
between <code class="docutils literal notranslate"><span class="pre">-16</span></code> and <code class="docutils literal notranslate"><span class="pre">16</span></code> pixels (to the bottom right) and fill up any new
pixels with zero (black values). The translation value is sampled once
per image and is the same for both axis.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="p">{</span><span class="s2">"x"</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="s2">"y"</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)})</span>
</pre></div>
</div>
<p>Translate all images on the x-axis by a random value
between <code class="docutils literal notranslate"><span class="pre">-16</span></code> and <code class="docutils literal notranslate"><span class="pre">16</span></code> pixels (to the right) and on the y-axis by a
random value between <code class="docutils literal notranslate"><span class="pre">-4</span></code> and <code class="docutils literal notranslate"><span class="pre">4</span></code> pixels to the bottom. The sampling
happens independently per axis, so even if both intervals were identical,
the sampled axis-wise values would likely be different.
This also fills up any new pixels with zero (black values).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Same as in the above <cite>scale</cite> example, but uses (randomly) either
nearest neighbour interpolation or linear interpolation. If <cite>order</cite> is
not specified, <code class="docutils literal notranslate"><span class="pre">order=1</span></code> would be used by default.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
</pre></div>
</div>
<p>Same as in the <cite>translate_px</cite> example above, but newly created pixels
are now filled with a random color (sampled once per image and the
same for all newly created pixels within that image).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="p">[</span><span class="s2">"constant"</span><span class="p">,</span> <span class="s2">"replicate"</span><span class="p">])</span>
</pre></div>
</div>
<p>Similar to the previous example, but the newly created pixels are
filled with black pixels in half of all images (mode <code class="docutils literal notranslate"><span class="pre">constant</span></code> with
default <cite>cval</cite> being <code class="docutils literal notranslate"><span class="pre">0</span></code>) and in the other half of all images using
<code class="docutils literal notranslate"><span class="pre">replicate</span></code> mode, which repeats the color of the spatially closest pixel
of the corresponding image edge.</p>
</dd></div></div></body>
</html>