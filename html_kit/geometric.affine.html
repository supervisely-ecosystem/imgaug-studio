
<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="Docutils 0.17: http://docutils.sourceforge.net/" name="generator"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>my_script module — Python  documentation</title>
<link href="_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="_static/copybutton.css" rel="stylesheet" type="text/css"/>
<!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
<script data-url_root="./" id="documentation_options" src="_static/documentation_options.js" type="text/javascript"></script>
<script src="_static/jquery.js"></script>
<script src="_static/underscore.js"></script>
<script src="_static/doctools.js"></script>
<script src="_static/clipboard.min.js"></script>
<script src="_static/copybutton.js"></script>
<script src="_static/js/theme.js" type="text/javascript"></script>
<link href="genindex.html" rel="index" title="Index"/>
<link href="search.html" rel="search" title="Search"/>
<link href="modules.html" rel="prev" title="my_file"/>
<style>
       ul.simple li {
         list-style: disc;
         margin-left: 24px;
       }
     </style></head>
<body class=""><div><div><dd>
<p>Augmenter to apply affine transformations to images.</p>
<p>This is mostly a wrapper around the corresponding classes and functions
in OpenCV and skimage.</p>
<p>Affine transformations involve:</p>
<blockquote>
<div><ul class="simple">
<li><p>Translation (“move” image on the x-/y-axis)</p></li>
<li><p>Rotation</p></li>
<li><p>Scaling (“zoom” in/out)</p></li>
<li><p>Shear (move one side of the image, turning a square into a trapezoid)</p></li>
</ul>
</div></blockquote>
<p>All such transformations can create “new” pixels in the image without a
defined content, e.g. if the image is translated to the left, pixels
are created on the right.
A method has to be defined to deal with these pixel values. The
parameters <cite>cval</cite> and <cite>mode</cite> of this class deal with this.</p>
<p>Some transformations involve interpolations between several pixels
of the input image to generate output pixel values. The parameter <cite>order</cite>
deals with the method of interpolation used for this.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While this augmenter supports segmentation maps and heatmaps that
have a different size than the corresponding image, it is strongly
recommended to use the same aspect ratios. E.g. for an image of
shape <code class="docutils literal notranslate"><span class="pre">(200,</span> <span class="pre">100,</span> <span class="pre">3)</span></code>, good segmap/heatmap array shapes also follow
a <code class="docutils literal notranslate"><span class="pre">2:1</span></code> ratio and ideally are <code class="docutils literal notranslate"><span class="pre">(200,</span> <span class="pre">100,</span> <span class="pre">C)</span></code>, <code class="docutils literal notranslate"><span class="pre">(100,</span> <span class="pre">50,</span> <span class="pre">C)</span></code> or
<code class="docutils literal notranslate"><span class="pre">(50,</span> <span class="pre">25,</span> <span class="pre">C)</span></code>. Otherwise, transformations involving rotations or
shearing will produce unaligned outputs.
For performance reasons, there is no explicit validation of whether
the aspect ratios are similar.</p>
</div>
<p><strong>Supported dtypes</strong>:</p>
<p>if (backend=”skimage”, order in [0, 1]):</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">uint8</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint32</span></code>: yes; tested (1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint64</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int8</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int32</span></code>: yes; tested  (1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int64</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float32</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float64</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float128</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code>: yes; tested</p></li>
</ul>
<ul class="simple">
<li><ol class="arabic simple">
<li><p>scikit-image converts internally to float64, which might
affect the accuracy of large integers. In tests this seemed
to not be an issue.</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>results too inaccurate</p></li>
</ol>
</li>
</ul>
</div></blockquote>
<p>if (backend=”skimage”, order in [3, 4]):</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">uint8</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint32</span></code>: yes; tested (1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint64</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int8</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int32</span></code>: yes; tested  (1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int64</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float32</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float64</span></code>: limited; tested (3)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float128</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code>: yes; tested</p></li>
</ul>
<ul class="simple">
<li><ol class="arabic simple">
<li><p>scikit-image converts internally to float64, which might
affect the accuracy of large integers. In tests this seemed
to not be an issue.</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>results too inaccurate</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p><code class="docutils literal notranslate"><span class="pre">NaN</span></code> around minimum and maximum of float64 value range</p></li>
</ol>
</li>
</ul>
</div></blockquote>
<p>if (backend=”skimage”, order=5]):</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">uint8</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint32</span></code>: yes; tested (1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint64</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int8</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int32</span></code>: yes; tested  (1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int64</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float32</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float64</span></code>: limited; not tested (3)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float128</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code>: yes; tested</p></li>
</ul>
<ul class="simple">
<li><ol class="arabic simple">
<li><p>scikit-image converts internally to <code class="docutils literal notranslate"><span class="pre">float64</span></code>, which
might affect the accuracy of large integers. In tests
this seemed to not be an issue.</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>results too inaccurate</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p><code class="docutils literal notranslate"><span class="pre">NaN</span></code> around minimum and maximum of float64 value range</p></li>
</ol>
</li>
</ul>
</div></blockquote>
<p>if (backend=”cv2”, order=0):</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">uint8</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint32</span></code>: no (1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint64</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int8</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int32</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int64</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float16</span></code>: yes; tested (3)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float32</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float64</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float128</span></code>: no (1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code>: yes; tested (3)</p></li>
</ul>
<ul class="simple">
<li><ol class="arabic simple">
<li><p>rejected by cv2</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>changed to <code class="docutils literal notranslate"><span class="pre">int32</span></code> by cv2</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p>mapped internally to <code class="docutils literal notranslate"><span class="pre">float32</span></code></p></li>
</ol>
</li>
</ul>
</div></blockquote>
<p>if (backend=”cv2”, order=1):</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">uint8</span></code>: yes; fully tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint32</span></code>: no (1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint64</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int8</span></code>: yes; tested (3)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int32</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int64</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float16</span></code>: yes; tested (4)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float32</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float64</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float128</span></code>: no (1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code>: yes; tested (4)</p></li>
</ul>
<ul class="simple">
<li><ol class="arabic simple">
<li><p>rejected by cv2</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>causes cv2 error: <code class="docutils literal notranslate"><span class="pre">cv2.error:</span> <span class="pre">OpenCV(3.4.4)</span>
<span class="pre">(...)imgwarp.cpp:1805:</span> <span class="pre">error:</span>
<span class="pre">(-215:Assertion</span> <span class="pre">failed)</span> <span class="pre">ifunc</span> <span class="pre">!=</span> <span class="pre">0</span> <span class="pre">in</span> <span class="pre">function</span> <span class="pre">'remap'</span></code></p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p>mapped internally to <code class="docutils literal notranslate"><span class="pre">int16</span></code></p></li>
</ol>
</li>
<li><ol class="arabic simple" start="4">
<li><p>mapped internally to <code class="docutils literal notranslate"><span class="pre">float32</span></code></p></li>
</ol>
</li>
</ul>
</div></blockquote>
<p>if (backend=”cv2”, order=3):</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">uint8</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint32</span></code>: no (1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint64</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int8</span></code>: yes; tested (3)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int16</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int32</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int64</span></code>: no (2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float16</span></code>: yes; tested (4)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float32</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float64</span></code>: yes; tested</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float128</span></code>: no (1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code>: yes; tested (4)</p></li>
</ul>
<ul class="simple">
<li><ol class="arabic simple">
<li><p>rejected by cv2</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>causes cv2 error: <code class="docutils literal notranslate"><span class="pre">cv2.error:</span> <span class="pre">OpenCV(3.4.4)</span>
<span class="pre">(...)imgwarp.cpp:1805:</span> <span class="pre">error:</span>
<span class="pre">(-215:Assertion</span> <span class="pre">failed)</span> <span class="pre">ifunc</span> <span class="pre">!=</span> <span class="pre">0</span> <span class="pre">in</span> <span class="pre">function</span> <span class="pre">'remap'</span></code></p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p>mapped internally to <code class="docutils literal notranslate"><span class="pre">int16</span></code></p></li>
</ol>
</li>
<li><ol class="arabic simple" start="4">
<li><p>mapped internally to <code class="docutils literal notranslate"><span class="pre">float32</span></code></p></li>
</ol>
</li>
</ul>
</div></blockquote>
<dl>
<dt>scale<span class="classifier">number or tuple of number or list of number or imgaug.parameters.StochasticParameter or dict {“x”: number/tuple/list/StochasticParameter, “y”: number/tuple/list/StochasticParameter}, optional</span></dt><dd><p>Scaling factor to use, where <code class="docutils literal notranslate"><span class="pre">1.0</span></code> denotes “no change” and
<code class="docutils literal notranslate"><span class="pre">0.5</span></code> is zoomed out to <code class="docutils literal notranslate"><span class="pre">50</span></code> percent of the original size.</p>
<blockquote>
<div><ul class="simple">
<li><p>If a single number, then that value will be used for all images.</p></li>
<li><p>If a tuple <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>, then a value will be uniformly sampled
per image from the interval <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b]</span></code>. That value will be
used identically for both x- and y-axis.</p></li>
<li><p>If a list, then a random value will be sampled from that list
per image (again, used for both x- and y-axis).</p></li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, then from that parameter a value
will be sampled per image (again, used for both x- and y-axis).</p></li>
<li><p>If a dictionary, then it is expected to have the keys <code class="docutils literal notranslate"><span class="pre">x</span></code>
and/or <code class="docutils literal notranslate"><span class="pre">y</span></code>. Each of these keys can have the same values as
described above. Using a dictionary allows to set different
values for the two axis and sampling will then happen
<em>independently</em> per axis, resulting in samples that differ
between the axes.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>translate_percent<span class="classifier">None or number or tuple of number or list of number or imgaug.parameters.StochasticParameter or dict {“x”: number/tuple/list/StochasticParameter, “y”: number/tuple/list/StochasticParameter}, optional</span></dt><dd><p>Translation as a fraction of the image height/width (x-translation,
y-translation), where <code class="docutils literal notranslate"><span class="pre">0</span></code> denotes “no change” and <code class="docutils literal notranslate"><span class="pre">0.5</span></code> denotes
“half of the axis size”.</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code> then equivalent to <code class="docutils literal notranslate"><span class="pre">0.0</span></code> unless <cite>translate_px</cite> has
a value other than <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p>If a single number, then that value will be used for all images.</p></li>
<li><p>If a tuple <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>, then a value will be uniformly sampled
per image from the interval <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b]</span></code>. That sampled fraction
value will be used identically for both x- and y-axis.</p></li>
<li><p>If a list, then a random value will be sampled from that list
per image (again, used for both x- and y-axis).</p></li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, then from that parameter a value
will be sampled per image (again, used for both x- and y-axis).</p></li>
<li><p>If a dictionary, then it is expected to have the keys <code class="docutils literal notranslate"><span class="pre">x</span></code>
and/or <code class="docutils literal notranslate"><span class="pre">y</span></code>. Each of these keys can have the same values as
described above. Using a dictionary allows to set different
values for the two axis and sampling will then happen
<em>independently</em> per axis, resulting in samples that differ
between the axes.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>translate_px<span class="classifier">None or int or tuple of int or list of int or imgaug.parameters.StochasticParameter or dict {“x”: int/tuple/list/StochasticParameter, “y”: int/tuple/list/StochasticParameter}, optional</span></dt><dd><p>Translation in pixels.</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code> then equivalent to <code class="docutils literal notranslate"><span class="pre">0</span></code> unless <cite>translate_percent</cite>
has a value other than <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p>If a single int, then that value will be used for all images.</p></li>
<li><p>If a tuple <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>, then a value will be uniformly sampled
per image from the discrete interval <code class="docutils literal notranslate"><span class="pre">[a..b]</span></code>. That number
will be used identically for both x- and y-axis.</p></li>
<li><p>If a list, then a random value will be sampled from that list
per image (again, used for both x- and y-axis).</p></li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, then from that parameter a value
will be sampled per image (again, used for both x- and y-axis).</p></li>
<li><p>If a dictionary, then it is expected to have the keys <code class="docutils literal notranslate"><span class="pre">x</span></code>
and/or <code class="docutils literal notranslate"><span class="pre">y</span></code>. Each of these keys can have the same values as
described above. Using a dictionary allows to set different
values for the two axis and sampling will then happen
<em>independently</em> per axis, resulting in samples that differ
between the axes.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>rotate<span class="classifier">number or tuple of number or list of number or imgaug.parameters.StochasticParameter, optional</span></dt><dd><p>Rotation in degrees (<strong>NOT</strong> radians), i.e. expected value range is
around <code class="docutils literal notranslate"><span class="pre">[-360,</span> <span class="pre">360]</span></code>. Rotation happens around the <em>center</em> of the
image, not the top left corner as in some other frameworks.</p>
<blockquote>
<div><ul class="simple">
<li><p>If a number, then that value will be used for all images.</p></li>
<li><p>If a tuple <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>, then a value will be uniformly sampled
per image from the interval <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b]</span></code> and used as the rotation
value.</p></li>
<li><p>If a list, then a random value will be sampled from that list
per image.</p></li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, then this parameter will be used to
sample the rotation value per image.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>shear<span class="classifier">number or tuple of number or list of number or imgaug.parameters.StochasticParameter or dict {“x”: int/tuple/list/StochasticParameter, “y”: int/tuple/list/StochasticParameter}, optional</span></dt><dd><p>Shear in degrees (<strong>NOT</strong> radians), i.e. expected value range is
around <code class="docutils literal notranslate"><span class="pre">[-360,</span> <span class="pre">360]</span></code>, with reasonable values being in the range
of <code class="docutils literal notranslate"><span class="pre">[-45,</span> <span class="pre">45]</span></code>.</p>
<blockquote>
<div><ul class="simple">
<li><p>If a number, then that value will be used for all images as
the shear on the x-axis (no shear on the y-axis will be done).</p></li>
<li><p>If a tuple <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>, then two value will be uniformly sampled
per image from the interval <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b]</span></code> and be used as the
x- and y-shear value.</p></li>
<li><p>If a list, then two random values will be sampled from that list
per image, denoting x- and y-shear.</p></li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, then this parameter will be used
to sample the x- and y-shear values per image.</p></li>
<li><p>If a dictionary, then similar to <cite>translate_percent</cite>, i.e. one
<code class="docutils literal notranslate"><span class="pre">x</span></code> key and/or one <code class="docutils literal notranslate"><span class="pre">y</span></code> key are expected, denoting the
shearing on the x- and y-axis respectively. The allowed datatypes
are again <code class="docutils literal notranslate"><span class="pre">number</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple</span></code> <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code> or
<code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>order<span class="classifier">int or iterable of int or imgaug.ALL or imgaug.parameters.StochasticParameter, optional</span></dt><dd><p>Interpolation order to use. Same meaning as in <code class="docutils literal notranslate"><span class="pre">skimage</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>: <code class="docutils literal notranslate"><span class="pre">Nearest-neighbor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code>: <code class="docutils literal notranslate"><span class="pre">Bi-linear</span></code> (default)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code>: <code class="docutils literal notranslate"><span class="pre">Bi-quadratic</span></code> (not recommended by skimage)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code>: <code class="docutils literal notranslate"><span class="pre">Bi-cubic</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4</span></code>: <code class="docutils literal notranslate"><span class="pre">Bi-quartic</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">5</span></code>: <code class="docutils literal notranslate"><span class="pre">Bi-quintic</span></code></p></li>
</ul>
</div></blockquote>
<p>Method <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">1</span></code> are fast, <code class="docutils literal notranslate"><span class="pre">3</span></code> is a bit slower, <code class="docutils literal notranslate"><span class="pre">4</span></code> and
<code class="docutils literal notranslate"><span class="pre">5</span></code> are very slow. If the backend is <code class="docutils literal notranslate"><span class="pre">cv2</span></code>, the mapping to
OpenCV’s interpolation modes is as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">cv2.INTER_NEAREST</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">cv2.INTER_LINEAR</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">cv2.INTER_CUBIC</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">cv2.INTER_CUBIC</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">cv2.INTER_CUBIC</span></code></p></li>
</ul>
</div></blockquote>
<p>As datatypes this parameter accepts:</p>
<blockquote>
<div><ul class="simple">
<li><p>If a single <code class="docutils literal notranslate"><span class="pre">int</span></code>, then that order will be used for all images.</p></li>
<li><p>If a list, then a random value will be sampled from that list
per image.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">imgaug.ALL</span></code>, then equivalant to list <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5]</span></code>
in case of <code class="docutils literal notranslate"><span class="pre">backend=skimage</span></code> and otherwise <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">3]</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, then that parameter is queried per
image to sample the order value to use.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>cval<span class="classifier">number or tuple of number or list of number or imgaug.ALL or imgaug.parameters.StochasticParameter, optional</span></dt><dd><p>The constant value to use when filling in newly created pixels.
(E.g. translating by 1px to the right will create a new 1px-wide
column of pixels on the left of the image).  The value is only used
when <cite>mode=constant</cite>. The expected value range is <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">255]</span></code> for
<code class="docutils literal notranslate"><span class="pre">uint8</span></code> images. It may be a float value.</p>
<blockquote>
<div><ul class="simple">
<li><p>If this is a single number, then that value will be used
(e.g. 0 results in black pixels).</p></li>
<li><p>If a tuple <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>, then three values (for three image
channels) will be uniformly sampled per image from the
interval <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b]</span></code>.</p></li>
<li><p>If a list, then a random value will be sampled from that list
per image.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">imgaug.ALL</span></code> then equivalent to tuple <a href="#id1"><span class="problematic" id="id2">``</span></a>(0, 255)`.</p></li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, a new value will be sampled from
the parameter per image.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>mode<span class="classifier">str or list of str or imgaug.ALL or imgaug.parameters.StochasticParameter, optional</span></dt><dd><p>Method to use when filling in newly created pixels.
Same meaning as in <code class="docutils literal notranslate"><span class="pre">skimage</span></code> (and <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.pad()</span></code>):</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">constant</span></code>: Pads with a constant value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge</span></code>: Pads with the edge values of array</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">symmetric</span></code>: Pads with the reflection of the vector mirrored
along the edge of the array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reflect</span></code>: Pads with the reflection of the vector mirrored on
the first and last values of the vector along each axis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wrap</span></code>: Pads with the wrap of the vector along the axis.
The first values are used to pad the end and the end values
are used to pad the beginning.</p></li>
</ul>
</div></blockquote>
<p>If <code class="docutils literal notranslate"><span class="pre">cv2</span></code> is chosen as the backend the mapping is as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">constant</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_CONSTANT</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REPLICATE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">symmetric</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reflect</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_REFLECT_101</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wrap</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">cv2.BORDER_WRAP</span></code></p></li>
</ul>
</div></blockquote>
<p>The datatype of the parameter may be:</p>
<blockquote>
<div><ul class="simple">
<li><p>If a single string, then that mode will be used for all images.</p></li>
<li><p>If a list of strings, then a random mode will be picked
from that list per image.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">imgaug.ALL</span></code>, then a random mode from all possible modes
will be picked.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">StochasticParameter</span></code>, then the mode will be sampled from
that parameter per image, i.e. it must return only the above
mentioned strings.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>fit_output<span class="classifier">bool, optional</span></dt><dd><p>Whether to modify the affine transformation so that the whole output
image is always contained in the image plane (<code class="docutils literal notranslate"><span class="pre">True</span></code>) or accept
parts of the image being outside the image plane (<code class="docutils literal notranslate"><span class="pre">False</span></code>).
This can be thought of as first applying the affine transformation
and then applying a second transformation to “zoom in” on the new
image so that it fits the image plane,
This is useful to avoid corners of the image being outside of the image
plane after applying rotations. It will however negate translation
and scaling.
Note also that activating this may lead to image sizes differing from
the input image sizes. To avoid this, wrap <code class="docutils literal notranslate"><span class="pre">Affine</span></code> in
<code class="xref py py-class docutils literal notranslate"><span class="pre">KeepSizeByResize</span></code>,
e.g. <code class="docutils literal notranslate"><span class="pre">KeepSizeByResize(Affine(...))</span></code>.</p>
</dd>
<dt>backend<span class="classifier">str, optional</span></dt><dd><p>Framework to use as a backend. Valid values are <code class="docutils literal notranslate"><span class="pre">auto</span></code>, <code class="docutils literal notranslate"><span class="pre">skimage</span></code>
(scikit-image’s warp) and <code class="docutils literal notranslate"><span class="pre">cv2</span></code> (OpenCV’s warp).
If <code class="docutils literal notranslate"><span class="pre">auto</span></code> is used, the augmenter will automatically try
to use <code class="docutils literal notranslate"><span class="pre">cv2</span></code> whenever possible (order must be in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">3]</span></code>). It
will silently fall back to skimage if order/dtype is not supported by
cv2. cv2 is generally faster than skimage. It also supports RGB cvals,
while skimage will resort to intensity cvals (i.e. 3x the same value
as RGB). If <code class="docutils literal notranslate"><span class="pre">cv2</span></code> is chosen and order is <code class="docutils literal notranslate"><span class="pre">2</span></code> or <code class="docutils literal notranslate"><span class="pre">4</span></code>, it will
automatically fall back to order <code class="docutils literal notranslate"><span class="pre">3</span></code>.</p>
</dd>
<dt>seed<span class="classifier">None or int or imgaug.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence or numpy.random.RandomState, optional</span></dt><dd><p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">__init__()</span></code>.</p>
</dd>
<dt>name<span class="classifier">None or str, optional</span></dt><dd><p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">__init__()</span></code>.</p>
</dd>
<dt>random_state<span class="classifier">None or int or imgaug.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence or numpy.random.RandomState, optional</span></dt><dd><p>Old name for parameter <cite>seed</cite>.
Its usage will not yet cause a deprecation warning,
but it is still recommended to use <cite>seed</cite> now.
Outdated since 0.4.0.</p>
</dd>
<dt>deterministic<span class="classifier">bool, optional</span></dt><dd><p>Deprecated since 0.4.0.
See method <code class="docutils literal notranslate"><span class="pre">to_deterministic()</span></code> for an alternative and for
details about what the “deterministic mode” actually does.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">imgaug.augmenters</span> <span class="k">as</span> <span class="nn">iaa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Zoom in on all images by a factor of <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
<p>Translate all images on the x- and y-axis by 16 pixels (towards the
bottom right) and fill up any new pixels with zero (black values).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">translate_percent</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>Translate all images on the x- and y-axis by <code class="docutils literal notranslate"><span class="pre">10</span></code> percent of their
width/height (towards the bottom right). The pixel values are computed
per axis based on that axis’ size. Fill up any new pixels with zero
(black values).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">rotate</span><span class="o">=</span><span class="mi">35</span><span class="p">)</span>
</pre></div>
</div>
<p>Rotate all images by <code class="docutils literal notranslate"><span class="pre">35</span></code> <em>degrees</em>. Fill up any new pixels with zero
(black values).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">shear</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
<p>Shear all images by <code class="docutils literal notranslate"><span class="pre">15</span></code> <em>degrees</em>. Fill up any new pixels with zero
(black values).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
</pre></div>
</div>
<p>Translate all images on the x- and y-axis by a random value
between <code class="docutils literal notranslate"><span class="pre">-16</span></code> and <code class="docutils literal notranslate"><span class="pre">16</span></code> pixels (to the bottom right) and fill up any new
pixels with zero (black values). The translation value is sampled once
per image and is the same for both axis.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="p">{</span><span class="s2">"x"</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="s2">"y"</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)})</span>
</pre></div>
</div>
<p>Translate all images on the x-axis by a random value
between <code class="docutils literal notranslate"><span class="pre">-16</span></code> and <code class="docutils literal notranslate"><span class="pre">16</span></code> pixels (to the right) and on the y-axis by a
random value between <code class="docutils literal notranslate"><span class="pre">-4</span></code> and <code class="docutils literal notranslate"><span class="pre">4</span></code> pixels to the bottom. The sampling
happens independently per axis, so even if both intervals were identical,
the sampled axis-wise values would likely be different.
This also fills up any new pixels with zero (black values).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Same as in the above <cite>scale</cite> example, but uses (randomly) either
nearest neighbour interpolation or linear interpolation. If <cite>order</cite> is
not specified, <code class="docutils literal notranslate"><span class="pre">order=1</span></code> would be used by default.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
</pre></div>
</div>
<p>Same as in the <cite>translate_px</cite> example above, but newly created pixels
are now filled with a random color (sampled once per image and the
same for all newly created pixels within that image).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="p">[</span><span class="s2">"constant"</span><span class="p">,</span> <span class="s2">"edge"</span><span class="p">])</span>
</pre></div>
</div>
<p>Similar to the previous example, but the newly created pixels are
filled with black pixels in half of all images (mode <code class="docutils literal notranslate"><span class="pre">constant</span></code> with
default <cite>cval</cite> being <code class="docutils literal notranslate"><span class="pre">0</span></code>) and in the other half of all images using
<code class="docutils literal notranslate"><span class="pre">edge</span></code> mode, which repeats the color of the spatially closest pixel
of the corresponding image edge.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">shear</span><span class="o">=</span><span class="p">{</span><span class="s2">"y"</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">45</span><span class="p">,</span> <span class="mi">45</span><span class="p">)})</span>
</pre></div>
</div>
<p>Shear images only on the y-axis. Set <cite>shear</cite> to <code class="docutils literal notranslate"><span class="pre">shear=(-45,</span> <span class="pre">45)</span></code> to
shear randomly on both axes, using for each image the same sample for
both the x- and y-axis. Use <code class="docutils literal notranslate"><span class="pre">shear={"x":</span> <span class="pre">(-45,</span> <span class="pre">45),</span> <span class="pre">"y":</span> <span class="pre">(-45,</span> <span class="pre">45)}</span></code>
to get independent samples per axis.</p>
</dd></div></div></body>
</html>